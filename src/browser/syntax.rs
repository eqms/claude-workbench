//! Syntax-highlighted HTML preview for text files
//!
//! Uses syntect for syntax highlighting with support for 500+ languages.

use anyhow::Result;
use std::path::{Path, PathBuf};
use syntect::{highlighting::ThemeSet, html::highlighted_html_for_string, parsing::SyntaxSet};

const TEXT_HTML_TEMPLATE: &str = r#"<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{title}</title>
    <style>
        :root {
            color-scheme: dark;
        }
        body {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', Consolas, monospace;
            margin: 0;
            padding: 0;
            background: #1e1e1e;
            color: #d4d4d4;
        }
        .header {
            background: #2d2d2d;
            padding: 12px 20px;
            border-bottom: 1px solid #404040;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .filename {
            color: #6db3f2;
            font-weight: 600;
        }
        .meta {
            color: #888;
            font-size: 0.85em;
        }
        .content {
            padding: 0;
            overflow-x: auto;
        }
        pre {
            margin: 0;
            padding: 16px 20px;
            line-height: 1.5;
            font-size: 13px;
            overflow-x: auto;
        }
        .footer {
            background: #2d2d2d;
            padding: 8px 20px;
            border-top: 1px solid #404040;
            font-size: 0.75em;
            color: #666;
            text-align: center;
        }
    </style>
</head>
<body>
<div class="header">
    <span class="filename">{filename}</span>
    <span class="meta">{language} • {size} • {lines} lines</span>
</div>
<div class="content">
{highlighted_code}
</div>
<div class="footer">
    Generated by Claude Workbench
</div>
</body>
</html>"#;

/// Check if file can be syntax-highlighted via syntect
pub fn can_syntax_highlight(path: &Path) -> bool {
    let ss = SyntaxSet::load_defaults_newlines();

    // Check by extension first
    if let Some(ext) = path.extension().and_then(|e| e.to_str()) {
        if ss.find_syntax_by_extension(ext).is_some() {
            return true;
        }
    }

    // Also check common config files by name
    if let Some(name) = path.file_name().and_then(|n| n.to_str()) {
        let lower_name = name.to_lowercase();
        if matches!(
            lower_name.as_str(),
            "makefile"
                | "dockerfile"
                | "gemfile"
                | "rakefile"
                | "cmakelists.txt"
                | ".gitignore"
                | ".gitattributes"
                | ".editorconfig"
                | ".env"
        ) {
            return true;
        }
    }

    false
}

/// Convert text file to HTML with syntax highlighting
pub fn text_to_html(path: &Path) -> Result<PathBuf> {
    let content = std::fs::read_to_string(path)?;
    let ss = SyntaxSet::load_defaults_newlines();
    let ts = ThemeSet::load_defaults();

    // Get syntax for this file
    let syntax = path
        .extension()
        .and_then(|ext| ext.to_str())
        .and_then(|ext| ss.find_syntax_by_extension(ext))
        .or_else(|| {
            // Try by filename for special files
            path.file_name().and_then(|n| n.to_str()).and_then(|name| {
                let lower = name.to_lowercase();
                match lower.as_str() {
                    "makefile" => ss.find_syntax_by_extension("makefile"),
                    "dockerfile" => ss.find_syntax_by_extension("dockerfile"),
                    "gemfile" | "rakefile" => ss.find_syntax_by_extension("rb"),
                    "cmakelists.txt" => ss.find_syntax_by_extension("cmake"),
                    _ if lower.starts_with(".git") => ss.find_syntax_by_extension("gitconfig"),
                    _ if lower.starts_with(".env") => ss.find_syntax_by_extension("sh"),
                    _ => None,
                }
            })
        })
        .unwrap_or_else(|| ss.find_syntax_plain_text());

    // Use base16-ocean.dark theme (dark mode friendly)
    let theme = &ts.themes["base16-ocean.dark"];

    // Generate highlighted HTML
    let highlighted = highlighted_html_for_string(&content, &ss, syntax, theme)?;

    // Get file metadata
    let filename = path
        .file_name()
        .and_then(|n| n.to_str())
        .unwrap_or("unknown");
    let language = detect_language_name(path, &ss);
    let size = format_file_size(content.len());
    let lines = content.lines().count();

    // Build final HTML
    let html = TEXT_HTML_TEMPLATE
        .replace("{title}", filename)
        .replace("{filename}", filename)
        .replace("{language}", &language)
        .replace("{size}", &size)
        .replace("{lines}", &lines.to_string())
        .replace("{highlighted_code}", &highlighted);

    // Create temp file
    let path_hash = path
        .to_string_lossy()
        .bytes()
        .fold(0u64, |acc, b| acc.wrapping_add(b as u64).wrapping_mul(31));
    let temp_name = format!("syntax_{:x}.html", path_hash);
    let temp_path = std::env::temp_dir().join(temp_name);

    std::fs::write(&temp_path, html)?;
    Ok(temp_path)
}

/// Format file size in human-readable form
fn format_file_size(bytes: usize) -> String {
    const KB: usize = 1024;
    const MB: usize = KB * 1024;

    if bytes >= MB {
        format!("{:.1} MB", bytes as f64 / MB as f64)
    } else if bytes >= KB {
        format!("{:.1} KB", bytes as f64 / KB as f64)
    } else {
        format!("{} B", bytes)
    }
}

/// Detect human-readable language name
fn detect_language_name(path: &Path, ss: &SyntaxSet) -> String {
    // Try by extension
    if let Some(ext) = path.extension().and_then(|e| e.to_str()) {
        if let Some(syntax) = ss.find_syntax_by_extension(ext) {
            return syntax.name.clone();
        }
    }

    // Try by filename
    if let Some(name) = path.file_name().and_then(|n| n.to_str()) {
        let lower = name.to_lowercase();
        return match lower.as_str() {
            "makefile" => "Makefile".to_string(),
            "dockerfile" => "Dockerfile".to_string(),
            "gemfile" => "Ruby (Gemfile)".to_string(),
            "rakefile" => "Ruby (Rakefile)".to_string(),
            "cmakelists.txt" => "CMake".to_string(),
            _ if lower.starts_with(".git") => "Git Config".to_string(),
            _ if lower.starts_with(".env") => "Environment".to_string(),
            _ => "Plain Text".to_string(),
        };
    }

    "Plain Text".to_string()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_can_syntax_highlight() {
        // Common code files (verified in syntect defaults)
        assert!(can_syntax_highlight(Path::new("test.rs")));
        assert!(can_syntax_highlight(Path::new("test.py")));
        assert!(can_syntax_highlight(Path::new("test.js")));
        assert!(can_syntax_highlight(Path::new("test.java")));
        assert!(can_syntax_highlight(Path::new("test.c")));
        assert!(can_syntax_highlight(Path::new("test.cpp")));
        assert!(can_syntax_highlight(Path::new("test.h")));
        assert!(can_syntax_highlight(Path::new("test.rb")));

        // Config files (yaml/json supported by default)
        assert!(can_syntax_highlight(Path::new("config.yaml")));
        assert!(can_syntax_highlight(Path::new("config.json")));

        // Shell scripts
        assert!(can_syntax_highlight(Path::new("script.sh")));

        // Web files
        assert!(can_syntax_highlight(Path::new("page.html")));
        assert!(can_syntax_highlight(Path::new("style.css")));
        assert!(can_syntax_highlight(Path::new("data.xml")));

        // Special files by name (our custom handling)
        assert!(can_syntax_highlight(Path::new("Makefile")));
        assert!(can_syntax_highlight(Path::new("Dockerfile")));

        // Non-text files should return false
        assert!(!can_syntax_highlight(Path::new("image.png")));
        assert!(!can_syntax_highlight(Path::new("binary.exe")));
        assert!(!can_syntax_highlight(Path::new("document.pdf")));
    }

    #[test]
    fn test_format_file_size() {
        assert_eq!(format_file_size(500), "500 B");
        assert_eq!(format_file_size(1024), "1.0 KB");
        assert_eq!(format_file_size(1536), "1.5 KB");
        assert_eq!(format_file_size(1048576), "1.0 MB");
    }
}
