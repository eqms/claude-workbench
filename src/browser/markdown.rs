//! Markdown to HTML conversion for browser preview

use anyhow::Result;
use std::path::{Path, PathBuf};

const HTML_TEMPLATE: &str = r#"<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{title}</title>
    <style>
        :root {
            color-scheme: light dark;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 2rem;
            line-height: 1.6;
            color: #333;
            background: #fff;
        }
        @media (prefers-color-scheme: dark) {
            body { background: #1e1e1e; color: #d4d4d4; }
            code { background: #2d2d2d; color: #e8e8e8; }
            pre { background: #2d2d2d; color: #e8e8e8; }
            pre code { color: #e8e8e8; }
            blockquote { border-color: #444; color: #aaa; }
            th { background: #3a3a3a; color: #ffffff; font-weight: 600; }
            td { background: #2a2a2a; color: #e8e8e8; }
            th, td { border-color: #555; }
            a { color: #6db3f2; }
            h1, h2 { border-color: #444; }
        }
        h1, h2, h3, h4, h5, h6 { margin-top: 1.5em; margin-bottom: 0.5em; }
        h1 { border-bottom: 2px solid #eee; padding-bottom: 0.3em; }
        h2 { border-bottom: 1px solid #eee; padding-bottom: 0.3em; }
        code {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', Consolas, monospace;
            background: #f4f4f4;
            color: #333;
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-size: 0.9em;
        }
        pre {
            background: #f4f4f4;
            color: #333;
            padding: 1rem;
            overflow-x: auto;
            border-radius: 5px;
        }
        pre code {
            background: none;
            color: inherit;
            padding: 0;
        }
        blockquote {
            border-left: 4px solid #ddd;
            margin: 1em 0;
            padding-left: 1rem;
            color: #666;
        }
        img { max-width: 100%; height: auto; }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
        }
        th, td {
            border: 1px solid #ccc;
            padding: 8px 12px;
            text-align: left;
        }
        th { background: #e0e0e0; color: #1a1a1a; font-weight: 600; }
        td { background: #fafafa; color: #333; }
        a { color: #0366d6; text-decoration: none; }
        a:hover { text-decoration: underline; }
        ul, ol { padding-left: 2em; }
        li { margin: 0.25em 0; }
        hr { border: none; border-top: 1px solid #eee; margin: 2em 0; }
        .footer {
            margin-top: 3rem;
            padding-top: 1rem;
            border-top: 1px solid #eee;
            font-size: 0.8em;
            color: #999;
        }
    </style>
</head>
<body>
{content}
<div class="footer">
    Generated by Claude Workbench
</div>
</body>
</html>"#;

/// Convert markdown file to HTML and return temp file path
pub fn markdown_to_html(md_path: &Path) -> Result<PathBuf> {
    use pulldown_cmark::{html, Options, Parser};

    let md_content = std::fs::read_to_string(md_path)?;
    let title = md_path
        .file_stem()
        .and_then(|s| s.to_str())
        .unwrap_or("Preview");

    // Enable all markdown extensions
    let options = Options::all();
    let parser = Parser::new_ext(&md_content, options);

    let mut html_content = String::new();
    html::push_html(&mut html_content, parser);

    let html = HTML_TEMPLATE
        .replace("{title}", title)
        .replace("{content}", &html_content);

    // Create temp file with unique name based on source path
    // Use a hash of the full path for uniqueness
    let path_hash = md_path
        .to_string_lossy()
        .bytes()
        .fold(0u64, |acc, b| acc.wrapping_add(b as u64).wrapping_mul(31));
    let temp_name = format!("preview_{:x}.html", path_hash);
    let temp_path = std::env::temp_dir().join(temp_name);

    std::fs::write(&temp_path, html)?;
    Ok(temp_path)
}
